//
//  ImageValet.swift
//  ImageValet
//
//  Created by Anthony Miller on 12/10/15.
//

import Foundation

import Alamofire
import AlamofireImage

/// `ImageValet` provides lazy delivery of an image from a local or remote source to a `UIImageView`.
open class ImageValet: Equatable {
  
  /**
   The source of an image for an `ImageValet`.
   
   - InMemory:    The image is stored in memory as a `UIImage`.
      - image:        The `UIImage` stored in memory.
   
   - URL:         The image is stored remotely or locally and can be access with an `NSURL`.
      - URL:          The `NSURL` to access the image.
      - placeholder:  An optional `UIImage` to use a placeholder while the image from the `URL` is retrieved.
   
   - URLRequest:  The image is stored remotely or locally and can be access with an `NSURLRequest`.
      - request:      The `NSURLRequest` to access the image.
      - placeholder:  An optional `UIImage` to use a placeholder while the image from the `request` is retrieved.
   
   - Operation:   The image can be retrieved through an asynchronous operation.
      - operation:    The `ImageOperation` to be run in order to load the image.
      - placeholder:  An optional `UIImage` to use a placeholder while the `operation` runs.
   */
  public enum ImageSource: Equatable {
    
    case inMemory(image: UIImage),
    url(Foundation.URL, placeholder: UIImage?),
    urlRequest(Foundation.URLRequest, placeholder: UIImage?),
    operation(ImageOperation, placeholder: UIImage?)
    
  }
  
  /// A closure with a completion block that recieves a `UIImage?`.
  public typealias ImageOperation = (_ completion:(_ image: UIImage?) -> Void) -> Void
  
  /// The error domain for all errors generated by `ImageValet`
  static let ErrorDomain = "com.AnthonyMDev.ImageValet"
  
  /// The error codes for all errors generated by `ImageValet`
  public struct ImageValetErrorCodes {
    
    /// An `Operation` image source ran its operation, but `nil` was returned.
    static let OperationReturnedNoImage: Int = 4001
  }
  
  /// The source of the image that the valet will manage.
  open let source: ImageSource
  
  /// The image that the valet manages. If the image has not been retrieved yet, this will be `nil`.
  open fileprivate(set) var image: UIImage?
  
  /*
  *  MARK: Initialization
  */
  
  /**
  Initializes an `ImageValet` with a given `ImageSource`.
  
  - parameter source: The source used to retrieve the image for the valet.
  
  - returns: An `ImageValet` for the given source.
  */
  public init(source: ImageSource) {
    self.source = source
    
    switch source {
    case .inMemory(let image):
      self.image = image
      
    default: break
    }
  }
  
  /*
  *  MARK: - Deliver Image
  */
  
  /**
  Delivers the image for the valet to the given completion block. If the image must be retrieved, it is retrieved asychronously before the completion block is called.
  
  - parameter completion: The completion block to deliver the valet's `image` to.
  */
  open func deliver(_ completion: (Result<UIImage, NSError>) -> Void) {
    if let image = image {
      completion(.Success(image))
      return
    }
    
    switch source {
    case .inMemory(let image):
      completion(.Success(image))
      
    case .url(let URL, _):
      downloadImageWithRequest(URLRequest(URL: URL), completion: completion)
      
    case .urlRequest(let URLRequest, _):
      downloadImageWithRequest(URLRequest, completion: completion)
      
    case .operation(let operation,_):
      operation() { image in
        if let image = image {
          self.image = image
          completion(.Success(image))
          
        } else {
          completion(.Failure(NSError(domain: ImageValet.ErrorDomain,
            code: ImageValetErrorCodes.OperationReturnedNoImage,
            userInfo: nil)))
        }
      }
    }
  }
  
  fileprivate func downloadImageWithRequest(_ URLRequest: Foundation.URLRequest, completion: ((Result<UIImage, NSError>) -> Void)) {
    ImageDownloader.defaultInstance.downloadImage(URLRequest: URLRequest,
      completion: { (response) -> Void in
        completion(response.result)
    })
  }
  
  /**
  Delivers (sets) the image for the valet on the given `UIImageView`. If the image must be retrieved, it is retrieved asychronously and then set to the image view.
  
  - parameter imageView: The image view to deliver the valet's `image` to.
  */
  open func deliverToImageView(_ imageView: UIImageView) {
    if let image = image {
      imageView.image = image
      return
    }
    
    switch source {
    case .inMemory(let image):
      imageView.image = image
      
    case .url(let URL,let placeholder):
      deliverImageToImageView(imageView,
        request: URLRequest(url: URL),
        placeholder: placeholder)
      
    case .urlRequest(let request, let placeholder):
      deliverImageToImageView(imageView,
        request: request,
        placeholder: placeholder)
      
    case .operation(let operation, let placeholder):
      imageView.image = placeholder
      
      operation() { image in
        if let image = image {
          imageView.image = image
          self.image = image
        }
      }
    }
  }
  
  fileprivate func deliverImageToImageView(_ imageView: UIImageView, request: URLRequest, placeholder: UIImage?) {
    imageView.af_setImageWithURLRequest(request,
      placeholderImage: placeholder,
      filter: nil,
      imageTransition: .CrossDissolve(0.2),
      completion: { [weak self] (response) -> Void in
        if let image = response.result.value {
          self?.image = image
        }
      })
  }
  
}

// MARK: - UIImageView+ImageValet
public extension UIImageView {
  
  /**
   Delivers the image from the given `ImageValet` to the image view.
   
   - parameter imageValet: The `ImageValet` to deliver it's `image`.
   */
  public func iv_deliverImage(_ imageValet: ImageValet) {
    imageValet.deliverToImageView(self)
  }
  
}

// MARK: - Equatable

public func ==(lhs: ImageValet, rhs: ImageValet) -> Bool {
  return lhs.source == rhs.source &&
  lhs.image == rhs.image
}

public func ==(lhs: ImageValet.ImageSource, rhs: ImageValet.ImageSource) -> Bool {
  switch (lhs, rhs) {
  case (.inMemory(let lhsImage), .inMemory(let rhsImage)):
    return lhsImage == rhsImage
    
  case (.url(let lhsURL, let lhsPlaceholder), .url(let rhsURL, let rhsPlaceholder)):
    return lhsURL == rhsURL
    && lhsPlaceholder == rhsPlaceholder
    
  case (.urlRequest(let lhsRequest, let lhsPlaceholder), .urlRequest(let rhsRequest, let rhsPlaceholder)):
    return lhsRequest == rhsRequest
      && lhsPlaceholder == rhsPlaceholder
    
  default: return false
  }
}
